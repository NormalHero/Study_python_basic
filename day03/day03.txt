셋
	셋(set)은 집합이다.
	집합은 순서(인덱스)가 존재하지 않는다.
	집합은 중복되는 요소를 담을 수 없다.

	값의 포함 여부를 확인할 때 사용한다.
	중복된 값을 제거할 때 사용한다.

셋 생성하기
	셋명 = {값1,값2,....}
	셋명 = set()

딕셔너리
	Key(키) - Value(값)가 한 쌍으로 저장된다.
	Key값을 이용해서 Value를 관리한다.
	Key값은 중복이 불가능하다.

딕셔너리 생성
	딕셔너리명 = {키1:값1, 키2:값2, ...}
	딕셔너리명 = dict()

딕셔너리 요소 추가
	딕셔너리명[새로운키] = 값

딕셔너리 요소 수정
	딕셔너리명[존재하는키] = 값

딕셔너리 요소 삭제
	del 딕셔너리명[키]

딕셔너리 요소 가져오기
	우리는 값을 사용하기 때문에 키값을 넘겨주고 값을 돌려받는다.
	print(딕셔너리명[키])

딕셔너리명.keys()
	키들만 모여있는 새로운 컬렉션 반환

딕셔너리명.values()
	값들만 모여있는 새로운 컬렉션 반환

딕셔너리명.items()
	(키,값) 튜플들이 모여있는 새로운 컬렉션 반환

a = "A,B".split(",") ---> ["A","B"]
a[0] : "A" / a[1] : "B"
-------------------------------------------------------------------
연산자
	기능이 있는 특수문자 또는 단어

우선순위
	한 문장 안에 여러개의 연산자가 있을 때 먼저 연산하는 순위

	최우선 연산자
	단항 연산자
	산술 연산자
	쉬프트 연산자
	관계 연산자
	논리 연산자
	삼항 연산자
	대입 연산자

결합성
	우선순위가 같은 연산자가 한 문장안에 여러개 있을 때
	알맞은 연산 방향으로 결합 후 연산되는 성질

	(1+2)+3+4+5
	(3+3)+4+5
	(6+4)+5
	10+5
	15

비트 연산
	bit	: 컴퓨터 용량의 최소단위, 1 또는 0이 저장되는 공간
	byte	: 8 bit, 데이터의 최소단위

	14 : 01110
	17 : 10001

	&(AND)	: 논리곱			두 비트가 모두 1 일때 1

	14&17 --> (2진법) 01110 & 10001 --> (2진법) 00000 --> (10진법) 0

	|(OR)	: 논리합			두 비트중 하나라도 1이면 1
	
	14|17 --> (2진법) 01110 & 10001 --> (2진법) 11111 --> (10진법) 31

	^(XOR)	: 배타논리합		두 비트가 서로 다르면 1

	14^17 --> (2진법) 01110 ^ 10001 --> (2진법) 11111 --> (10진법) 31
	
	~(NOT)	: 비트뒤집기, 논리부정	비트가 1이면 0으로, 0이면 1로 변환
			부호비트까지 뒤집어준다.(양수 -> 음수, 음수 -> 양수)

	~14 --> (2진법) ~01110 --> (2진법) 10001 --> (10진법) -15
	~a = -(a+1)

비트 이동(쉬프트)
	
	a>>b : a를 b만큼 우로 비트이동
		
	14 >> 1 --> (2진법) 01110 >> 1 --> (2진법) 00111 --> (10진법) 7

	a<<b : a를 b만큼 좌로 비트이동

	14 << 1 --> (2진법) 01110 << 1 --> (2진법) 011100 --> (10진법) 28

조건식
	조건을 정해주고 제시하는 식
	주장하는 식(10은 3보다 커, 이 수는 100이야)
	결과가 True, False 단 두가지로 나오는 식
	관계연산자로 만들어진다.

관계 연산자
	
	>, <	: 초과, 미만
	>=, <=	: 이상, 이하
	==	: 같다
	!=	: 다르다

논리 연산자
	A,B는 조건식으로 가정한다.
	
	A and B	: A,B 두 조건식의 연산 결과가 둘 다 True 라면 True
	A or B	: A,B 두 조건식의 연산 결과중 하나라도 True 라면 True

단항 연산자
	not A	: 조건식의 연산 결과가 True 라면 False로, False 라면 True로 변경

삼항 연산자
	(참일 때 오는 부분) if 조건식 else (거짓일 때 오는 부분)

	참일 때 수행할 문장 if 조건식 else 거짓일 때 수행할 문장
	참일 때의 값 if 조건식 else 거짓일 때의 값

	경우의 수가 두가지일 때 사용하는 것이 좋다.

연산자
	최우선 연산자
		()
	단항 연산자
	이항 연산자
		산술 연산자
			+ - * / // %
		쉬프트 연산자
			>> <<
		관계 연산자
			> < >= <= == !=
		논리 연산자
			and or

	삼항 연산자
		if else
	대입 연산자
		=

제어문
	흐름을 제어하기 위한 문장

	조건문(선택제어문)
		if ~ elif ~ else
	반복문(반복제어문)
		while
		for

조건문
	조건에 따라서 경우의 수를 나눌 때
	흐름을 나눌 때
	특정 상태를 물어볼 때(ex:비밀번호가 abcd니? 입력한게 3이니?)

	if 조건식1:
		조건식1의 연산 결과가 True라면 실행
	elif 조건식2:
		조건식2의 연산 결과가 True라면 실행
	...
	else:
		위의 조건식들의 연산 결과가 모드 False라면 실행

	조건식 중 하나가 참인 경우 안의 내용을 모두 실행한 후
	아래 내용들은 하지 않고 세트를 탈출한다. elif와 else는 생략 가능하다.















