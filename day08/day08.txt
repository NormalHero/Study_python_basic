상속(inheritance)
	1. 기존에 사용중인 클래스의 필드가 새롭게 만드는 클래스와
	공통요소가 많다면 재구현 하지 않고 상속을 받아서 사용한다.

	2. 여러 클래스를 만들고자 할 때 각 클래스가 공통적인 요소가 많다면
	부모 클래스를 먼저 만들고 그 클래스들에게 상속시켜 준다.

class A:
	A의 필드

class B(A):
	B의 필드

b = B()
실제로 b 객체는 A의 필드+B의 필드 둘 다 가지고 있다.

A : 부모 클래스, 슈퍼 클래스, 상위 클래스, 기반 클래스
B : 자식 클래스, 서브 클래스, 하위 클래스, 파생 클래스

자식 타입으로 객체 생성시 일어나는 일
	자식 객체는 자식 생성자를 호출하여 객체화를 진행한다.
	메모리에 자식 필드만 올라갔다면 자식 객체로 절대 부모 필드에
	존재하는 것들을 사용할 수 없다. 따라서 자식 생성자를 호출하게 되면
	부모의 생성자가 자동으로 호출되고 그 때 부모 필드가 먼저 메모리에
	올라가게 된다. 그 이후에 자식의 필드도 따라 붙게 되고 그 결과
	자식 객체는 부모 필드에도 접근할 수 있게 된다.

다형성(Polymorphism)
	오버라이딩(재정의)
		부모 필드에 이미 a()라는 메소드가 존재한다면
		부모 생성자가 먼저 호출되기 때문에 부모의 a()가
		먼저 메모리에 올라간다. 그 다음 자식 필드를
		메모리에 올릴 때 같은 이름의 a() 메소드가 선언되어
		있다면 같은 이름으로 2개가 만들어지지 않고 기존에
		올라가있는 부모의 a() 메소드에 자식에서 작성한 내용이
		덮어 씌워지게 된다. 그러므로 자식 객체로 a()를
		사용하면 재정의된 기능으로 사용되며 이것을
		오버라이딩(Overriding) 이라 한다.

예외처리
	에러 : 심각한 오류
	예외 : 덜 심각한 오류

try ~ except문
	try:
		예외가 발생할 수 있는 문장

	except 예외클래스명:
		예외 발생시 실행할 문장

Exception 클래스
	모든 예외들의 부모 클래스
	예외가 어떤것이 발생할지 모를 때 사용
	확인용일뿐, 처리를 위해서 사용하지 않는다.

except 클래스명 as 객체명:
	예외객체 받아와서 사용 가능

파일 입출력
	파일객체 = open("경로/파일명.확장자","모드")

모드
	w : write
		파일 쓰기 모드(기존의 파일 내용에 덮어씌우기)
		파일이 존재하지 않는다면 파일을 생성한다.
	a : append
		파일 쓰기 모드(기존의 파일 내용에 추가하기)
	r : read
		파일 읽기 모드(기존의 파일 내용 읽어오기)

파일에 내용 쓰기
	파일객체.write("문자열")	: 파일에 문자열 쓰기
	파일객체.close()		: 파일에 적용

파일 내용 읽기
	파일객체.readlines()	: 파일에 있는 모든 줄들 읽어오기
			통째로 모든 줄들이 담겨있는 list이다.
			각 방에 한줄 한줄의 내용이 담겨있다.(enter도 포함)








